ADD_CORE_FILES(CMakeLists.txt)

PKG_SEARCH_MODULE(CppUnit cppunit REQUIRED)


if(WIN32)
MACRO(TULIP_FIND_EXTERNAL_LIB pattern result_var_name)
  UNSET(${result_var_name})
  UNSET(found_paths)
  FOREACH(win_path $ENV{CMAKE_LIBRARY_PATH} ${QT_BINARY_DIR} ${MINGW_BIN_PATH} ${CMAKE_LIBRARY_PATH})
    STRING(REPLACE "\\" "/" cmake_path "${win_path}")
    FILE(GLOB match "${cmake_path}/${pattern}")
    IF(match)
      GET_FILENAME_COMPONENT(match_absolute "${match}" ABSOLUTE)
      SET(found_paths ${found_paths} ${match_absolute})
    ENDIF(match)
  ENDFOREACH()
  IF(found_paths)
    LIST(REMOVE_DUPLICATES found_paths)
    SET(${result_var_name} ${found_paths})
  ENDIF(found_paths)
ENDMACRO(TULIP_FIND_EXTERNAL_LIB)

MACRO(TULIP_GET_DLL_NAME_FROM_IMPORT_LIBRARY import_library dll_name)
  UNSET(${dll_name})
  IF(MINGW)
    EXECUTE_PROCESS(COMMAND ${CMAKE_DLLTOOL} -I ${import_library} OUTPUT_VARIABLE DLL_FILENAME ERROR_VARIABLE DLLTOOL_ERROR)
    IF(DLLTOOL_ERROR)
      MESSAGE("${import_library} is not a valid import library (likely a copy of the associated dll). Please provide a valid one in order to determine the dll the application depends to.")
    ELSE(DLLTOOL_ERROR)
      STRING(STRIP ${DLL_FILENAME} ${dll_name})
    ENDIF(DLLTOOL_ERROR)
  ENDIF(MINGW)
  IF(MSVC)
    # Get path of MSVC compiler
    GET_FILENAME_COMPONENT(COMPILER_DIRECTORY ${CMAKE_CXX_COMPILER} DIRECTORY)
    # Get root path of Visual Studio
    IF(MSVC14)
      GET_FILENAME_COMPONENT(VS_DIR [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\VisualStudio\\14.0\\Setup\\VS;ProductDir] REALPATH)
    ELSEIF(MSVC12)
      GET_FILENAME_COMPONENT(VS_DIR [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\VisualStudio\\12.0\\Setup\\VS;ProductDir] REALPATH)
    ENDIF()
    # Add temporarily some paths to the PATH environment variable in order to locate some dlls needed to run lib.exe command (mspdb*.dll)
    SET(VS_IDE_DIR "${VS_DIR}/Common7/IDE")
    SET(VS_VC_BIN_DIR "${VS_DIR}/VC/bin")
    SET(PATH_BACKUP "$ENV{PATH}")
    SET(ENV{PATH} "${VS_IDE_DIR};${VS_VC_BIN_DIR};$ENV{PATH}")
    # Run the lib.exe command to list the content of the library file
    EXECUTE_PROCESS(COMMAND ${COMPILER_DIRECTORY}/lib.exe /list ${import_library} OUTPUT_VARIABLE LIBRARY_CONTENTS)
    # If the library is an import library, lib.exe outputs the associated dll name instead of the object files for a static library
    STRING(REGEX MATCH "[^\r?\n]+\\.dll" ${dll_name} ${LIBRARY_CONTENTS})
    # Restore original PATH environment variable value
    SET(ENV{PATH} "${PATH_BACKUP}")
  ENDIF(MSVC)
ENDMACRO(TULIP_GET_DLL_NAME_FROM_IMPORT_LIBRARY)
ENDIF(WIN32)

MACRO(UNIT_TEST)
  SET(TEST_NAME ${ARGV0})
  UNSET(TEST_SRCS)
  FOREACH(loop_var ${ARGN})
    STRING(REGEX MATCH ".*\\.cpp" TEST_SRC_FILE ${loop_var})
    IF(TEST_SRC_FILE)
      SET(TEST_SRCS ${TEST_SRCS} ${loop_var})
    ENDIF(TEST_SRC_FILE)
  ENDFOREACH()
  # this is a cpp[unit] test
  IF(TEST_SRCS)
    INCLUDE_DIRECTORIES(${TulipCoreBuildInclude} ${TulipCoreInclude} ${CppUnit_INCLUDE_DIRS} ${CMAKE_SOURCE_DIR}/tests/include)
    LINK_DIRECTORIES(${CppUnit_LIBRARY_DIRS})
    ADD_EXECUTABLE(${TEST_NAME} ${TEST_SRCS})
    ADD_DEPENDENCIES(runTests ${TEST_NAME})
    TARGET_LINK_LIBRARIES(${TEST_NAME} ${LibTulipCoreName} ${CppUnit_LIBRARIES})
    ADD_TEST(NAME ${TEST_NAME} COMMAND ${TEST_NAME} ${TEST_NAME})
  # otherwise this is a Python test
  ELSE()
    SET(PYTHON_TEST_MODULE ${ARGV1})
    FILE(COPY ${PYTHON_TEST_MODULE}.py DESTINATION ${CMAKE_CURRENT_BINARY_DIR})
    ADD_TEST(NAME ${TEST_NAME} COMMAND ${Python_EXECUTABLE} -m unittest ${PYTHON_TEST_MODULE} WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
  ENDIF()
  # In order to run the tests on windows, we need to add the paths of the dll dependencies (cppunit, tulip, gzstream)
  # in the PATH environment variable
  IF(WIN32)
    IF(MINGW)
      STRING(REGEX MATCH ".*dll\\.a" IMPORT_LIBRARY ${CppUnit_LIBRARIES})
      STRING(REGEX MATCH ".*dll" DLL_LIBRARY ${CppUnit_LIBRARIES})
      IF(IMPORT_LIBRARY)
        TULIP_GET_DLL_NAME_FROM_IMPORT_LIBRARY(${CppUnit_LIBRARIES} CppUnitDllName)
      ELSEIF(DLL_LIBRARY)
        GET_FILENAME_COMPONENT(CppUnitDllName ${CppUnit_LIBRARIES} NAME)
      ENDIF()
    ELSE(MINGW)
      TULIP_GET_DLL_NAME_FROM_IMPORT_LIBRARY(${CppUnit_LIBRARIES} CppUnitDllName)
    ENDIF(MINGW)
    IF(CppUnitDllName)
      TULIP_FIND_EXTERNAL_LIB(${CppUnitDllName} CppUnitDllPath)
      IF(CppUnitDllPath)
        GET_FILENAME_COMPONENT(CppUnitDllDir ${CppUnitDllPath} DIRECTORY)
      ENDIF(CppUnitDllPath)
    ENDIF()
    SET(NEWPATH "${CppUnitDllDir};${CMAKE_LIBRARY_PATH};${QT_BINARY_DIR};${PYTHON_HOME_PATH};${CMAKE_BINARY_DIR}/thirdparty/gzstream/;${CMAKE_BINARY_DIR}/thirdparty/ftgl")
    SET(NEWPATH "${NEWPATH};${CMAKE_BINARY_DIR}/library/tulip-core/src;${CMAKE_BINARY_DIR}/library/tulip-ogl/src;${CMAKE_BINARY_DIR}/library/tulip-gui/src;$ENV{PATH}")
    SET(NEWPATH "${NEWPATH};${CMAKE_BINARY_DIR}/thirdparty/libtess2;${CMAKE_BINARY_DIR}/thirdparty/OGDF;${CMAKE_BINARY_DIR}/library/tulip-ogdf;${CMAKE_BINARY_DIR}/library/tulip-python/src;$ENV{PATH}")
    STRING(REPLACE "\\;" ";" NEWPATH "${NEWPATH}")
    STRING(REPLACE ";" "\\;" NEWPATH "${NEWPATH}")
  ELSE(WIN32)
    SET(NEWPATH "$ENV{PATH}")
  ENDIF(WIN32)
  # add Tulip modules path to PYTHONPATH in order to run the Python tests
  SET(PYTHONPATH "${CMAKE_BINARY_DIR}/library/tulip-python/modules/;${TULIP_PYTHON_ROOT_FOLDER};${TULIPGUI_PYTHON_ROOT_FOLDER}")
  IF(WIN32)
    STRING(REPLACE "\\;" ";" PYTHONPATH "${PYTHONPATH}")
    STRING(REPLACE ";" "\\;" PYTHONPATH "${PYTHONPATH}")
  ELSE(WIN32)
    STRING(REPLACE ";" ":" PYTHONPATH "${PYTHONPATH}")
  ENDIF(WIN32)
  # set tests environment
  SET_TESTS_PROPERTIES(${TEST_NAME} PROPERTIES ENVIRONMENT "TULIP_BUILD_DIR=${CMAKE_BINARY_DIR};PYTHONPATH=${PYTHONPATH};PATH=${NEWPATH}")
ENDMACRO(UNIT_TEST)

ADD_SUBDIRECTORY(library)

ADD_DEPENDENCIES(runTests copyTulipPluginsPyInBuild)

IF(NOT TULIP_BUILD_CORE_ONLY)
  ADD_SUBDIRECTORY(plugins)
ENDIF(NOT TULIP_BUILD_CORE_ONLY)

ADD_SUBDIRECTORY(python)
ADD_SUBDIRECTORY(external_plugins_build)
